<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>提升</title>
    <script>
        /* 
            变量的提升：
                使用var声明变量时，声明变量的代码将会被最先执行（只会声明，不会赋值）,
                怎么理解先执行？：
                    指将所有的var 声明的变量改变一下，直接在最开头先声明，然后后续碰到的var 变量名 = ...看作变量名 = ...
            
            函数的提升：（值提升）只适用于函数名开头的
                在构建函数时，可以在构建函数之前就可以调用函数实现函数中的语句（在其他代码执行前被创建）
            let、const、class提升：
                使用上面的声明变量或类时，会发生一个提升，虽然会提示暂时性死区，但本质还是因为提前了的同时，JS解释器禁止在声明前进行访问


            为什么提升 ：
                JS解释器为了开辟出一个合适的内存空间（预留较大的空间），存放对应数量的变量和函数，会在解释前读取代码中的所有变量和函数，减少内存重新分配的次数，提升代码执行的性能，所有语言都存在
                这样的设置，但就JS提前访问不报错
        */
        
        // console.log(a);
        // var a = 10;

        // // console.log(fn);
        // fn()
        // // fn2();//会提示fn2不是函数，
        // console.log(fn2);
        // function fn() {
        //     console.log('123');
        // }
        // var fn2 = function() {//只会提升fn2这个变量
        //     console.log('345');
        // }


        // let a = 10;
        // const a = 10;
        // {
        //     console.log(a);

        //     const a = 20;//最总显示暂时性死区，而TDZ的原因在于禁止在声明前进行访问，按作用域链来讲，发现该代码块前并没有声明的a变量，应该往外层进行查找，从而找到外层
        //                 //的a变量，此时却返回来TDZ，说明还是提升了，并且将let a = 20；起码提升到访问之前
            
        // }
        
        // 对象并不会进行提升
        // console.log(obj);
        
        //  obj = Object();
        // obj.name = '孙悟空'
    </script>
</head>
<body>
    
</body>
</html>