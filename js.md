# JS

## 基础

标准是：ECMAscript

扩展ES：基本规范后，DOM、BOM、node.js....都属于扩展ES

### 特点

- 解释型语言：不需要通过编译，直接通过解释器（浏览器自带）边解释边执行

- 函数式编程：JS最关键的特点，通过函数实现功能强大且灵活的代码

- 单线程：JS是单线程语言，只能在同一时间完成一件事后才能继续完成下一件事情（降低了代码的复杂度），也降低了性能（通过异步解决）

- 面向对象：通过对象实现操作




### 编写位置

写在html内的任意位置
写在外部js文件中，使用script进行应用（src），不允许在引用的script内再继续编写js代码
写在某些标签的指定属性上

### 基本语法

多行注释：/* 注释内容*/
单行注释：//：注释掉右侧部分
JS严格区分大小写
JS中，多个空格和换行后被看成一个空格与换行
JS中，每个应该以分号结束，但JS解释器自动为每个JS语句增加分号，存在小概率事件，让解释器误解了JS语句的内容，在错误的位置给出错误的分号造成报错

### 字面量

就单纯一个值（1、"hello"、true、null...），无其他含义
JS中所有字面量可以直接使用，但不方便使用，可通过变量来使用

### 变量

用于“存储”字面量。并且被存放的字面量可以实现随意修改。
随意修改的原因在于JS中的变量没有类型约束，是动态的，因此可以随意修改
其实修改本质还是开辟了一个新的内存空间来存放新的字面量，原来的字面量还是老位置存在的

#### 变量的使用

- 声明变量：let 变量名1，2...(有块作用域)/var 变量名（没有块作用域）
- 变量赋值
- 声明和复制

#### 变量内存结构

​	在JS中，声明一个变量时，会在内存特定区域中开辟出一块区域来存放变量后“变量值”(此时变量值并不就是字面量)，根据上面提到的变量是动态的，因此存放的字面量大小也是无法估量的，会造成大了溢出，小了浪费的场景

#### 字面量存放

​	内存会先查看内存中是否含有该字面量，如果没有，会在内存的一块新区域开辟出一个新地方来存放字面量，因此上面的“变量值”存放了一个地址，地址指向了字面量（类似指针）
​	应当注意的是当两个变量被赋值为同一字面量时，此时两个变量存放的地址是指向同一块区域，当修改其中一个变量的赋值后，并不会影响另外一个变量的赋值，理由见上文，如果修改了两个变量指向地址的内容，此时两个变量的赋值才会发生变化。

### 常量

JS中，不能修改的变量就是常量。（通常将常量大写）

常量使用const修饰，修饰过后的常量只能赋值一次，意味着const将内存中的常量值固定死了，不让其可以指向其他位置

针对于对象中的某些不希望被修改的值，也会采取常量声明

### 标识符

​	可以自主命名的内容（变量、函数和类名的名称）

#### 标识符规范

​	标识符只能由字母、数字、下划线、$组成，且开头不能为数字

​	标识符不能为JS的关键字和保留字，也不建议为内置函数和类名（可以使用，但是被用于充当标识符，但是原有功能将被覆盖）

​	命名规范：

​		通常采用驼峰命名法 ：变量名开头首字母小写，每个单词首字母大写。maxLength

​		大驼峰命名法 ：变量名每个单词首字母大写。MaxLength

​		常量统一大写

### 数据类型

JS中数据的类型分为原始值和对象，原始值是构成JS数据的基石。

 原始值（可以看成基本类型的字面量）在JS中是不可变类型（为什么，因为改不了已经在内存中创建的原始值，修改变量只会让变量指向一块新的内存空间中新的原始值，原来的原始值一直都在），一旦创建就不可变

#### 数据类型检查

​	typeof 运算符

​	根据检测的数据类型，给出相应的数据类型。（需要注意的是，typeof返回到数据类型为String）

​	typeof是检测变量值的类型，并非是变量的类型。（变量无类型）

#### 原始值类型

Number ：数值

​	所有的整数和浮点数都属于数值类型

​	按照数值大小程度，以正常，近视值（丢失部分精度）、科学计数法、Infinity（一个特殊值，表示无穷）显示数值

​	NaN ：一个特殊值，表示一个非法数值

​	在实际场合中，应该避免出现Infinity和NaN两种情况，出现了来一个判断避免就行

​	进制表示方式：

​	0b ：二进制

​	0o ：八进制

​	0x ：十六进制

​	各进制数要求符号各进制对数的要求，且最终会以十进制数显示

BIgInt ：大整数

​	用于表示值很大的整数（不能为浮点数），表现形式为：数值后加一个‘n’；

​	表示范围为实际内存大小，内存可以存多大，表示数值就多大。

​	大整数不能与其他数据类型混合运算

String ：字符串

​	使用" "或‘ ’括起来的字符串（需要注意的是，用双引号、单引号括起来的字符不能出现换行，如果非要换行，则在每行最后面加一个"\"来连接下一行，但最终显示出的字符串并不会进行换行，只会用空格隔开）

​	转义字符（类似字符实体）

​		\\'  ：输出单引号

​		\\" ：输出双引号

​		\\\ ：输出反斜杠

​		\\t ：制表符

​		\\n ：换行

​        模板字符串：

​     	   使用反单引号实现：``,

​        	可以自动连接多行字符串不报错，相当于多行字符串,并会保留换行（不是主要）

​        	模板字符串中允许嵌套变量,嵌套其他变量：${变量名a}（相当于a存放的地址）

Boolean ：布尔值

​	用于进行逻辑判断

​	两个值：true、false（底层讲，Boolean按照数值来进行存放，true为1，false为0）

Null ：空

​	当变量被赋值为null，其类型为空，表一个空对象

​	留存小问题：在使用typeof检查空类型数据的类型时，会返回一个object，是历史遗留下来的问题

Undefined ：未定义

​	当变量未被赋值时或者赋值为undef时，数据类型为Undefined

Symbol ：符号

​	用于创建一个唯一标识

### 类型转换

 转换主要指其他类型转换为number、boolean和string（其他类型要么值少，转换为该类型无意义或者使用场景不多）

需要注意的是，这里转换并不是真正的将值的类型转换为另一种类型，因为**原始值（基本类型字面量）是不可修改的**，不可能真正实现转换，转换的实质就是在内存区域开辟一个新的空间，创建数据类型为指定类型后将原有内容保持不变的放入

#### 转字符串

1. 调用toString()方法

   ​	将其他类型的数据原封不动的转换为字符串类型

   ​	存在缺陷：针对于Null、Undefined两个原始值类型，调用toString方法时，会因为无法读取数据类型内容（因为本身没有内容）而报错

2. 调用String函数

   ​	其他类型转换与toString()方法一样	

   ​	对于Null、Undefined，调用String函数，会直接返回Null和Undefined两个值。

补充：

​	调用x的y方法为：x.y；

​	调用y函数为：y（传参）；

#### 转数值

1. Number函数

   ​	将其他类型数据（纯数字）转换为数值类型，在针对于转换本身内容存放的非数值内容时（存在字母的字符串）（boolean值并不算，因为本身底层就是1、0），会转换为一个NaN，如果是空值则转换为0（Null，'' 、' '）

2. 针对字符串专门转换的函数

   ​	paresInt() ：转换为整数

   ​		按照从左到右的顺序依次访问字符串中的每一个字符，如果是数字，则成功转换为数值，并继续往下访问，直到访问完字符串或遇到非数字的字符（包括小数点）时，停止转换，丢弃后面所有的字符（如果后面还有字符的话）；如果开头就是非空的其他类型字符，则返回NaN，开头为空格和正负符号时，正常显示数值（负号保留）

   ​	paresFloat() ：转换为浮点数

   ​		原理一致，但遇到小数点（单个，多个则截断）还会往下读取

#### 转布尔值

Boolean()函数：对于空的、错误的都为false，其余为true ，对象一般都为true

以上转换都属于显示转换或强制转换

### 运算符（操作符）

  可以对一个或多个值（操作数）进行运算

#### 算术运算符

​	+、-、*、/、%、**（加减乘除取余幂）

​	/ ：但除不尽时，会返回一个近似值，当除以0时，返回一个Infinity

​	对于除字符串加法的所有算术运算都是先将其他类型转换数值运算（隐似转换）后继续运算（可以实现类型转换）

​	字符串加法：拼串：将非字符类型的数据转换为字符串类型，然后连接起来。（可用于转换为字符串）

#### 赋值运算符

​	将赋值运算符的右边的值赋值给左边的变量（不能更改顺序），只有左边的变量才是变量，而右边出现的变量是被当做值来看待。

​	=、+=、-=、*=、/=、%=、**=

​	空赋值：??=  当左边变量为Null、Undefined时，才会将右边的值赋值给左边变量

#### 一元加减运算符

​      \+ ： 正号,不会影响数值的符号位

​      \- ：负号,对数值进行符号位取反

​      当非数值类型的数据进行正负运算时，会先转变成数值类型，在进行计算（可用于类型转换）

