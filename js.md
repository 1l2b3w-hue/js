# JS

## 基础

标准是：ECMAscript

扩展ES：基本规范后，DOM、BOM、node.js....都属于扩展ES

### 特点

- 解释型语言：不需要通过编译，直接通过解释器（浏览器自带）边解释边执行

- 函数式编程：JS最关键的特点，通过函数实现功能强大且灵活的代码

- 单线程：JS是单线程语言，只能在同一时间完成一件事后才能继续完成下一件事情（降低了代码的复杂度），也降低了性能（通过异步解决）

- 面向对象：通过对象实现操作




### 编写位置

写在html内的任意位置
写在外部js文件中，使用script进行应用（src），不允许在引用的script内再继续编写js代码
写在某些标签的指定属性上

### 基本语法

多行注释：/* 注释内容*/
单行注释：//：注释掉右侧部分
JS严格区分大小写
JS中，多个空格和换行后被看成一个空格与换行
JS中，每个应该以分号结束，但JS解释器自动为每个JS语句增加分号，存在小概率事件，让解释器误解了JS语句的内容，在错误的位置给出错误的分号造成报错

### 字面量

就单纯一个值（1、"hello"、true、null...），无其他含义
JS中所有字面量可以直接使用，但不方便使用，可通过变量来使用

### 变量

用于“存储”字面量。并且被存放的字面量可以实现随意修改。
随意修改的原因在于JS中的变量没有类型约束，是动态的，因此可以随意修改
其实修改本质还是开辟了一个新的内存空间来存放新的字面量，原来的字面量还是老位置存在的

#### 变量的使用

- 声明变量：let 变量名1，2...(有块作用域)/var 变量名（没有块作用域）
- 变量赋值
- 声明和复制

#### 变量内存结构

​	在JS中，声明一个变量时，会在内存特定区域中开辟出一块区域来存放变量后“变量值”(此时变量值并不就是字面量)，根据上面提到的变量是动态的，因此存放的字面量大小也是无法估量的，会造成大了溢出，小了浪费的场景

#### 字面量存放

​	内存会先查看内存中是否含有该字面量，如果没有，会在内存的一块新区域开辟出一个新地方来存放字面量，因此上面的“变量值”存放了一个地址，地址指向了字面量（类似指针）
​	应当注意的是当两个变量被赋值为同一字面量时，此时两个变量存放的地址是指向同一块区域，当修改其中一个变量的赋值后，并不会影响另外一个变量的赋值，理由见上文，如果修改了两个变量指向地址的内容，此时两个变量的赋值才会发生变化。

### 常量

JS中，不能修改的变量就是常量。（通常将常量大写）

常量使用const修饰，修饰过后的常量只能赋值一次，意味着const将内存中的常量值固定死了，不让其可以指向其他位置

针对于对象中的某些不希望被修改的值，也会采取常量声明

### 标识符

​	可以自主命名的内容（变量、函数和类名的名称）

#### 标识符规范

​	标识符只能由字母、数字、下划线、$组成，且开头不能为数字

​	标识符不能为JS的关键字和保留字，也不建议为内置函数和类名（可以使用，但是被用于充当标识符，但是原有功能将被覆盖）

​	命名规范：

​		通常采用驼峰命名法 ：变量名开头首字母小写，每个单词首字母大写。maxLength

​		大驼峰命名法 ：变量名每个单词首字母大写。MaxLength

​		常量统一大写

### 数据类型

JS中数据的类型分为原始值和对象，原始值是构成JS数据的基石。

 原始值（可以看成基本类型的字面量）在JS中是不可变类型（为什么，因为改不了已经在内存中创建的原始值，修改变量只会让变量指向一块新的内存空间中新的原始值，原来的原始值一直都在），一旦创建就不可变

#### 数据类型检查

​	typeof 运算符

​	根据检测的数据类型，给出相应的数据类型。（需要注意的是，typeof返回到数据类型为String）

​	typeof是检测变量值的类型，并非是变量的类型。（变量无类型）

#### 原始值类型

Number ：数值

​	所有的整数和浮点数都属于数值类型

​	按照数值大小程度，以正常，近视值（丢失部分精度）、科学计数法、Infinity（一个特殊值，表示无穷）显示数值

​	NaN ：一个特殊值，表示一个非法数值

​	在实际场合中，应该避免出现Infinity和NaN两种情况，出现了来一个判断避免就行

​	进制表示方式：

​	0b ：二进制

​	0o ：八进制

​	0x ：十六进制

​	各进制数要求符号各进制对数的要求，且最终会以十进制数显示

BIgInt ：大整数

​	用于表示值很大的整数（不能为浮点数），表现形式为：数值后加一个‘n’；

​	表示范围为实际内存大小，内存可以存多大，表示数值就多大。

​	大整数不能与其他数据类型混合运算

String ：字符串

​	使用" "或‘ ’括起来的字符串（需要注意的是，用双引号、单引号括起来的字符不能出现换行，如果非要换行，则在每行最后面加一个"\"来连接下一行，但最终显示出的字符串并不会进行换行，只会用空格隔开）

​	转义字符（类似字符实体）

​		\\'  ：输出单引号

​		\\" ：输出双引号

​		\\\ ：输出反斜杠

​		\\t ：制表符

​		\\n ：换行

​        模板字符串：

​     	   使用反单引号实现：``,

​        	可以自动连接多行字符串不报错，相当于多行字符串,并会保留换行（不是主要）

​        	模板字符串中允许嵌套变量,嵌套其他变量：${变量名a}（相当于a存放的地址）

Boolean ：布尔值

​	用于进行逻辑判断

​	两个值：true、false（底层讲，Boolean按照数值来进行存放，true为1，false为0）

Null ：空

​	当变量被赋值为null，其类型为空，表一个空对象

​	留存小问题：在使用typeof检查空类型数据的类型时，会返回一个object，是历史遗留下来的问题

Undefined ：未定义

​	当变量未被赋值时或者赋值为undef时，数据类型为Undefined

Symbol ：符号

​	用于创建一个唯一标识

### 类型转换

 转换主要指其他类型转换为number、boolean和string（其他类型要么值少，转换为该类型无意义或者使用场景不多）

需要注意的是，这里转换并不是真正的将值的类型转换为另一种类型，因为**原始值（基本类型字面量）是不可修改的**，不可能真正实现转换，转换的实质就是在内存区域开辟一个新的空间，创建数据类型为指定类型后将原有内容保持不变的放入

#### 转字符串

1. 调用toString()方法

   ​	将其他类型的数据原封不动的转换为字符串类型

   ​	存在缺陷：针对于Null、Undefined两个原始值类型，调用toString方法时，会因为无法读取数据类型内容（因为本身没有内容）而报错

2. 调用String函数

   ​	其他类型转换与toString()方法一样	

   ​	对于Null、Undefined，调用String函数，会直接返回Null和Undefined两个值。

补充：

​	调用x的y方法为：x.y；

​	调用y函数为：y（传参）；

#### 转数值

1. Number函数

   ​	将其他类型数据（纯数字）转换为数值类型，在针对于转换本身内容存放的非数值内容时（存在字母的字符串）（boolean值并不算，因为本身底层就是1、0），会转换为一个NaN，如果是空值则转换为0（Null，' ' ）

2. 针对字符串专门转换的函数

   ​	paresInt() ：转换为整数

   ​		按照从左到右的顺序依次访问字符串中的每一个字符，如果是数字，则成功转换为数值，并继续往下访问，直到访问完字符串或遇到非数字的字符（包括小数点）时，停止转换，丢弃后面所有的字符（如果后面还有字符的话）；如果开头就是非空的其他类型字符，则返回NaN，开头为空格和正负符号时，正常显示数值（负号保留）

   ​	paresFloat() ：转换为浮点数

   ​		原理一致，但遇到小数点（单个，多个则截断）还会往下读取

#### 转布尔值

Boolean()函数：对于空的、错误的都为false，其余为true ，对象一般都为true

以上转换都属于显示转换或强制转换

## 运算符（操作符）

  可以对一个或多个值（操作数）进行运算

### 算术运算符

​	+、-、*、/、%、**（加减乘除取余幂）

​	/ ：但除不尽时，会返回一个近似值，当除以0时，返回一个Infinity

​	对于除字符串加法的所有算术运算都是先将其他类型转换数值运算（隐似转换）后继续运算（可以实现类型转换）

​	字符串加法：拼串：将非字符类型的数据转换为字符串类型，然后连接起来。（可用于转换为字符串）

### 赋值运算符

​	将赋值运算符的右边的值赋值给左边的变量（不能更改顺序），只有左边的变量才是变量，而右边出现的变量是被当做值来看待。

​	=、+=、-=、*=、/=、%=、**=

​	空赋值：??=  当左边变量为Null、Undefined时，才会将右边的值赋值给左边变量

### 一元加减运算符

​      \+ ： 正号,不会影响数值的符号位

​      \- ：负号,对数值进行符号位取反

​      当非数值类型的数据进行正负运算时，会先转变成数值类型，在进行计算（可用于类型转换）

### 自增自减运算符

​	++ ：自增运算符，有前置和后置，前置先加再用，后置则先用后加

​	-- ：自减运算符，用法与自增一致。

### 逻辑运算符

​	对非Boolean类型使用逻辑运算符时，会自动转换为Boolean类型后再运算

​	逻辑非 ：！

​		假成真，真成假

​		可以实现其他类型转Boolean（！！）

​	逻辑与 ：&&

​		全真为真，有假为假；（找false，有false为假，没有为false）

​		短路：当&&左侧值为假时，发生短路，不会再去计算和判断右侧值，返回左值（逻辑与返回原值）

​		返回原值：当进行逻辑与和逻辑或时（Boolean和非Boolean运算都一样），其返回值并不是Boolean类型的值，而是返回左值和右值两个中的某一原值；

​		       原则：当左值为真时，返回右值；左值为假时，返回左值

​	逻辑或 ：||

​		全假为假，有真为真；（找true，有true为true，没有为false）

​		短路：当||左侧为真，发生短路，不会计算和判断右侧值，

​		返回值原则：当左值为假时，返回右值；左值为真，返回左值

### 关系运算符

​		检查两个值之间的关系是否成立，成立true，不成立false

​		 当存在非数值类型转换时，会先将非数值类型转换为数值（通常情况下）类型，再进行比较

​        	两个字符串进行比较时，按照Unicode编码（包含了ASCII码，因此比较字母啥的可以按照ASCII来比较）来一次比较每个字符，先大为大

​        	当像比较两个字符串中数的大小时，应该将其中一个字符串转换为数值类型，摆脱两个字符串类型比较的规则

​	>、>=、<、<=

​	==、!=：相等与不等

​		 null 与 undefined进行相等比较是为true

​        	NaN出现在关系运算符中，都显示false(NaN与所有值都不等，包括他自身)（NaN出现在关系运算中，结果只会是false）。

​	===、!==：全等与不全等

​		再发生不同类型数据比较时，不会发生类型转换，因此，不同类型数据在证明是否全等时，都是fasle，证明不全等时，true

### 条件运算符

​	表达式 ？ a : b ：表达式为真，执行a，为假执行b

### 运算符优先级

 	优先级表：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Expressions_and_operators

​      	使用过程中，如果不知道谁的优先级高，用括号将你想要执行的顺序括起来就行，优先级直接拉满。

## 流程控制

### 	代码块

​		使用{ }括起来的JS代码，将JS代码进行分组，不影响执行顺序。同一组代码块内的内容，要么都执行，要么都不执行

​		let与var声明变量的区别：

​			let声明变量有块作用域，只能在其出现的{ }中产生作用，推荐使用

​			var声明变量无块作用域，可以实现跨不同{ }产生作用，

### 	流程控制语句

​		控制语句执行顺序

#### 		条件判断语句

​			1.if语句 
​				if(条件表达式1) { 代码块1 }

​				当条件表达式1为真时，执行代码块1中的JS代码，否则将不会执行

​				当没有{ }进行约束时，if语句默认与最近（下）的一条JS代码匹配，不会影响到其他JS代码。

​			2.if -else语句

​				if语句+else { 代码块2 }

​				当条件表达式1为真，执行代码块1，为假执行代码块2

​				else语句与最近（上）的if语句进行匹配

​			3.if-else if-else语句

​				if-else语句中间插入一个或多个else if（条件表达式2）{ 代码块3 }

​				当条件表达式1为真时，执行代码块1中的JS代码，为假，则判断第一个else if语句的条件表达式2，为真则执行代码块3，为假则继续判断吓一			条else if 语句，直到所有的else if 语句全部完成后，执行else中的代码块2.

​				但有一个代码块被执行后，就会停止执行后面的语句，跳出整个语句

#### 		条件分支语句

​			

```
switch(表达式) {
	case (表达式) :
		代码块
		break;
	.....
	default ：
		代码块
}
```

​		执行顺序 ：将switch中的表达式依次与case中的表达式进行全等比较，如果相同，则从该case为开始，从上往下执行所有代码（没有break的干扰下），如果存在break并执行到时，则停止执行后续代码并跳出switch。

​		default：当所有case都与switch的表达式不匹配时，执行default中的代码块，default可以放在任意位置，但要加break，不然还是从下到上继续执行。

#### 		循环语句

​			重复执行某一段代码

​			要求存在三种情况避免死循环：
​				初始化表达式

​				条件表达式

​				更新表达式

​			推荐死循环写法（部分场景必须用到死循环）：

​				

```
while(1){
	循环体
}
for(;;) {
	循环体
}

```

​			1.while语句

```
while(条件表达式) {
	循环体
}
```

​				执行顺序：

​					当条件表达式为真时，执行while中循环体的代码，执行完后继续判断条件表达式的结果....，假则跳出循环

​					当条件表达式恒为真时，发生死循环

​			2.do-while语句

```
do {
	循环体
}while（条件表达式）
```

​				执行顺序：

​					先执行do中的循环体，再判断条件表达式的真假，真继续执行do中循环体，假则跳出循环

​				与while的区别：

​					while ：先判断，再执行

​					do-while ：先执行，再判断，保证循环体至少执行一边。 

​			3.for语句

```
for(初始化表达式;条件表达式;更新表达式) {
	循环体
}
```

​				执行顺序：

​					先执行初始化表达式（let（推荐）、var生成的变量作用范围不同。只会执行一次），然后再判断条件表达式的真假，真则执行循环体后				执行更新表达式，然后继续判断条件表达式，执行或跳出。

​				三个表达式都可以省略，但要保留';'分隔。

​			循环嵌套 ：
​				外层循环一次，内层循环一个完整周期

​			break和continue：

​				break ：跳出switch语句和循环，只会影响最近的switch和循环

​				continue ：跳过本次循环，执行下一次循环

## 对象

​	JS中的复合类型数据，存放不同类型的数据（相当于容器）(并不存在作用域)；

​	存放的数据称为属性（属性名和属性值，对象中属性的值可以是任意属性类型，也可以是一个对象（函数）），

### 	定义 

​	let 变量名 = （new）Object();

​	let 变量名 = { 属性名 ：属性值 ，....}；（对象的字面量，类似数据结构）

​	typeof检查对象返回object

### 	创建属性

​	变量名.属性名 =属性值

​	属性名可以有任意字符组成（属性名在底层是属于字符串），但存在特殊字符时，使用变量名[属性名] =属性值来创建，取出和存储的方式一样

### 	删除属性 

​	delete 对象名.属性名 

​	当读取一个对象中没有到属性名时，并不会报错，而是返回undefined	

### 	symbol

​	创建唯一不易见的属性

​	使用符号类型（symbol）作为属性名，添加属性(一般情况下，不希望被别人看到和更改)

​	怎么实现：当使用[]去操作属性名时，里面可以是类名，变量名，对于变量名借助[]操作属性名时，本质是按照变量中的值操作

​		因此指定一个变量存放符号类型数据，然后再通过使用[变量名]来使用变量中的值去创建属性时，就是使用symbol创建属性

### 	枚举属性

​	语法 ：for(let 枚举名 in 对象名) { 语句 }

​	枚举过程中，会依次将属性名赋值给枚举名（也就是说，枚举名会暂时成为属性名，），但是symbol创建的属性名就无法被枚举

### in 运算符

​      "属性名" in 对象 :表示检查一个对象里面有没有这个属性,存在返回true，不存在返回false

### 对象内存结构 

​	变量名、变量值按照键值对表形式存放在栈内存中，变量值存放引用，指向存放在堆内存中的对象 （属性名和属性值），属性名和属性值成键值对表存	放在堆内存，属性值可以是直接存放的原始值或者是引用，用来指向存放在堆内存的或另一个对象

​	对于字符串的存储，引擎实现时可能将其存放在特定位置，然后实现逻辑上的直接存放（可能存在跳转到特定位置拿取）

​	两个对象在进行全等或等于比较时，是比较两者的地址

### 可变类型 

​	对象的可变性是指对象的属性可以增加、删除，属性值的修改，并不指存放变量值地址的内容发生改变

### 改变量和改对象

​	修改一个变量时，是新开辟一块空间存放新值，并不影响原来的值，也不会影响其他变量

​	修改一个对象时，会导致指向该对象的所有变量发生改变

​	因此，在使用变量声明对象时，常常会因为某些原因导致变量指向内容发生改变，不知道变量谁指谁了，提高代码复杂度

​        常用const去修饰存储对象的变量，禁止在为对象变量进行赋值操作

### 对象方法 

​	当对象的某个属性是函数时，称这个函数是该对象的方法，调用该函数就是调用对象的方法		

### window对象

​        window是一个对象， window对象代表浏览器的窗口（由浏览器提供），通过该对象可以实现对浏览器窗口的各种操作

​        window对象的属性可以通过window.来访问，也可以直接访问。创建一个函数可以看成创建window的方法

​    	还负责存储JS的内置对象和浏览器的宿主对象

​        var一个变量本质上就是在window上创建一个属性

​	在没有使用let、var、const声明一个变量时并赋值时，会直接在window对象中创建一个相同属性名和值的属性，等同于window.d=10（var d =10）

​        使用function创建的函数，相当于在window中创建了一个方法。

​        let一个变量并不会在window创建一个新属性，但let生成的变量一定存在，存在于一个秘密的地方

​        当let和var声明的变量名相同时，不会报错，但会优先访问let声明的变量

​	var声明的变量虽然没有块作用域，但因为函数存在函数作用域，因此在函数使用var声明一个变量时，超出函数后就消亡。

## 函数

### 	定义 

​		一个特殊的对象，可以存放语句，需要时进行调用来执行语句。

​		typeof检查函数类型时，返回function

### 	声明

​		function 函数名() { 语句 }; 调用：函数名()；

​		const 变量名 = function () { 语句 }; 调用：变量名()；

​		箭头函数 ：const 变量名 =() => { 语句 }/语句（一条）;调用：变量名()；

### 	参数 

​		形式参数

​			在函数定义时，可以设置多个不同的形参，

​			在函数中定义形参时，指定义了形参但并未对其赋值

​		实际参数

​			调用函数时，传递给函数的多个参数就是实参，实参会为对应位置的形参赋值（传递过程中，将实参存放的地址或引用进行传递）

​		形参与实惨数量

​			当形参数量大于实参时，多余形参将不会被赋值

​			当形参数量等于实参时，形参与实参进行一一对应，然后赋值

​			当形参数量小于实参时，多余实参将不会赋值。

​	因为JS中，参数是没有类型可言的，所有参数可以被赋予任意类型的数据，会在编写代码中造成意料之外的错误，因此传参过程中，应当进行强制转换来避免这些错误

​		对象参数

​			就简单的一个参数就是对象

​			当函数形参默认是一个对象时，该对象会在调用函数时被创建，函数结束时消亡，因此连续调用该函数时，看起来函数默认参数创建的对象是同一		个，但每当函数结束后就会消亡，如同转世一样。又怎么可能是同一个呢，转世后的人早已不是当初的人了

​			当然如果函数默认参数是指向一个已经创建的对象，这个对象本来就存在，连续调用并不会导致对象的消亡。对象也不会转世，对对象的修改也会		一直保留下来。

​		函数参数

​			就简单的一个参数是函数

​		箭头函数参数

​			一个特殊的地方：当箭头函数形参就只有一个时，可以省略括号（let a = a => {}），且不能为函数参数设默认值

### 	函数返回值

​		函数使用return来实现返回函数值，返回值可以是任意类型的数据

​		当没有return时，接受一个函数的返回值，会显示undefined。

​		函数一旦执行return语句，函数立即结束

​		箭头函数返回值

​			当一个箭头函数就一个返回语句时，可以不用写{ }和return，直接将返回内容写入就行

​			当一个箭头函数只有一个语句且要返回一个对象值时，应当使用（）将其包裹，让解释器知道里面的内容是返回值而不是函数语句

### 	作用域

​		一个变量起作用的区域

​		作用域生命周期

​			被创建开始到销毁之间。

​		全局作用域

​			网页被创建开始，到网页关闭结束

​			全部直接写在script标签内都属于全局变量，全局变量可以在任意位置被访问到

​		局部作用域

​			块作用域

​				代码块被创建时开始，代码块执行完毕时销毁

​          		      所有直接写入代码块的都位于块作用域中，块作用域的变量都属于局部变量，只能在所属块中被访问

​			函数作用域

​				 函数调用时产生，执行完毕销毁

​          			所有写入函数的都位于函数作用域中，位于函数作用域的变量都属于局部变量，只能在所属函数中被访问

​        			  每一次调用函数时，会产生新的作用域，互不影响

​		作用域链 

​			解决当访问一个变量时，解释器该如何去寻找一个变量

​			当开始访问某一个变量时，JS解释器第一步首先在所属块中开始查找，找到了就返回，如果没有找到，则往上一层块中进行查找，找到返回，没找到重复上一层块进行查找直到找到或找完所有父级块，返回找到的值或报错

​			查找原则 ：就近原则，不会访问同级块，函数在被创建时就确定了作用域，在任意位置调用按找函数块开始不断往上查找

### 	提升

​	 变量的提升：（声明提升）

​        使用var声明变量时，声明变量的代码将会被最先执行（只会声明，不会赋值）,

​        怎么理解先执行？：

​          指将所有的var 声明的变量改变一下位置，会在最开头先使用var声明出哪些变量，但并不赋值，只会在原有位置进行赋值操作

​      函数的提升：（值提升）只适用于函数名开头的

​        在构建函数时，可以在构建函数之前就可以调用函数实现函数中的语句（在其他代码执行前被创建）

​      let、const、class提升：

​        使用上面的声明变量或类时，会发生一个提升，虽然会提示暂时性死区（TDZ），但本质还是因为提前了的同时，JS解释器禁止在声明前进行访问

​      为什么提升 ：

​        告诉JS解释器，有什么变量名和函数名，你要好准备工作

函数、方法：

​	isNaN（） ：判断一个数据是否为NaN，是返回true，否则false

​	console.time() ：一个计时器，括号内容为计时器名字，计时器名称要求唯一

​	console.timeEnd() ： 结束一个最近的计时器

​	输入：

​	prompt （）：接受用户键盘输入的数据，其返回类型为String，可以增加提示信息

​	输出：

​	alert ：通过弹出提示框来输出信息（无，Undefined）

​	confirm ：通过弹出提示框来输出信息，点击确定返回true，点击取消返回false

​	document.write ：直接在页面中显示输出信息（无，Undefined）

​	console.log ：控制台显示输出信息（String）

技巧：

判断浮点数：将数模1，有余数则为浮点数，没有为整数

字符串索引：一个字符串可以通过类似C语言数组的形式快速访问字符串某个字符。（i[0]、i[1]...分别表示字符串i的第一个、二个...字符）

开平方 ：**.5；
