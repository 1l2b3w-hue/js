#  JS

## 基础

标准是：ECMAscript

扩展ES：基本规范后，DOM、BOM、node.js....都属于扩展ES

### 特点

- 解释型语言：不需要通过编译，直接通过解释器（浏览器自带）边解释边执行

- 函数式编程：JS最关键的特点，通过函数实现功能强大且灵活的代码

- 单线程：JS是单线程语言，只能在同一时间完成一件事后才能继续完成下一件事情（降低了代码的复杂度），也降低了性能（通过异步解决）

- 面向对象：通过对象实现操作




### 编写位置

写在html内的任意位置
写在外部js文件中，使用script进行应用（src），不允许在引用的script内再继续编写js代码
写在某些标签的指定属性上

### 基本语法

多行注释：/* 注释内容*/
单行注释：//：注释掉右侧部分
JS严格区分大小写
JS中，多个空格和换行后被看成一个空格与换行
JS中，每个应该以分号结束，但JS解释器自动为每个JS语句增加分号，存在小概率事件，让解释器误解了JS语句的内容，在错误的位置给出错误的分号造成报错

### 字面量

就单纯一个值（1、"hello"、true、null...），无其他含义
JS中所有字面量可以直接使用，但不方便使用，可通过变量来使用

### 变量

用于“存储”字面量。并且被存放的字面量可以实现随意修改。
随意修改的原因在于JS中的变量没有类型约束，是动态的，因此可以随意修改
其实修改本质还是开辟了一个新的内存空间来存放新的字面量，原来的字面量还是老位置存在的

#### 变量的使用

- 声明变量：let 变量名1，2...(有块作用域)/var 变量名（没有块作用域）
- 变量赋值
- 声明和复制

#### 变量内存结构

​	在JS中，声明一个变量时，会在内存特定区域中开辟出一块区域来存放变量后“变量值”(此时变量值并不就是字面量)，根据上面提到的变量是动态的，因此存放的字面量大小也是无法估量的，会造成大了溢出，小了浪费的场景

#### 字面量存放

​	内存会先查看内存中是否含有该字面量，如果没有，会在内存的一块新区域开辟出一个新地方来存放字面量，因此上面的“变量值”存放了一个地址，地址指向了字面量（类似指针）
​	应当注意的是当两个变量被赋值为同一字面量时，此时两个变量存放的地址是指向同一块区域，当修改其中一个变量的赋值后，并不会影响另外一个变量的赋值，理由见上文，如果修改了两个变量指向地址的内容，此时两个变量的赋值才会发生变化。

### 常量

JS中，不能修改的变量就是常量。（通常将常量大写）

常量使用const修饰，修饰过后的常量只能赋值一次，意味着const将内存中的常量值固定死了，不让其可以指向其他位置

针对于对象中的某些不希望被修改的值，也会采取常量声明

### 标识符

​	可以自主命名的内容（变量、函数和类名的名称）

#### 标识符规范

​	标识符只能由字母、数字、下划线、$组成，且开头不能为数字

​	标识符不能为JS的关键字和保留字，也不建议为内置函数和类名（可以使用，但是被用于充当标识符，但是原有功能将被覆盖）

​	命名规范：

​		通常采用驼峰命名法 ：变量名开头首字母小写，每个单词首字母大写。maxLength

​		大驼峰命名法 ：变量名每个单词首字母大写。MaxLength

​		常量统一大写

### 数据类型

JS中数据的类型分为原始值和对象，原始值是构成JS数据的基石。

 原始值（可以看成基本类型的字面量）在JS中是不可变类型（为什么，因为改不了已经在内存中创建的原始值，修改变量只会让变量指向一块新的内存空间中新的原始值，原来的原始值一直都在），一旦创建就不可变

#### 数据类型检查

​	typeof 运算符

​	根据检测的数据类型，给出相应的数据类型。（需要注意的是，typeof返回到数据类型为String）

​	typeof是检测变量值的类型，并非是变量的类型。（变量无类型）

#### 原始值类型

Number ：数值

​	所有的整数和浮点数都属于数值类型

​	按照数值大小程度，以正常，近视值（丢失部分精度）、科学计数法、Infinity（一个特殊值，表示无穷）显示数值

​	NaN ：一个特殊值，表示一个非法数值

​	在实际场合中，应该避免出现Infinity和NaN两种情况，出现了来一个判断避免就行

​	进制表示方式：

​	0b ：二进制

​	0o ：八进制

​	0x ：十六进制

​	各进制数要求符号各进制对数的要求，且最终会以十进制数显示

BIgInt ：大整数

​	用于表示值很大的整数（不能为浮点数），表现形式为：数值后加一个‘n’；

​	表示范围为实际内存大小，内存可以存多大，表示数值就多大。

​	大整数不能与其他数据类型混合运算

String ：字符串

​	使用" "或‘ ’括起来的字符串（需要注意的是，用双引号、单引号括起来的字符不能出现换行，如果非要换行，则在每行最后面加一个"\"来连接下一行，但最终显示出的字符串并不会进行换行，只会用空格隔开）

​	转义字符（类似字符实体）

​		\\'  ：输出单引号

​		\\" ：输出双引号

​		\\\ ：输出反斜杠

​		\\t ：制表符

​		\\n ：换行

​        模板字符串：

​     	   使用反单引号实现：``,

​        	可以自动连接多行字符串不报错，相当于多行字符串,并会保留换行（不是主要）

​        	模板字符串中允许嵌套变量,嵌套其他变量：${变量名a}（相当于a存放的地址）

Boolean ：布尔值

​	用于进行逻辑判断

​	两个值：true、false（底层讲，Boolean按照数值来进行存放，true为1，false为0）

Null ：空

​	当变量被赋值为null，其类型为空，表一个空对象

​	留存小问题：在使用typeof检查空类型数据的类型时，会返回一个object，是历史遗留下来的问题

Undefined ：未定义

​	当变量未被赋值时或者赋值为undef时，数据类型为Undefined

Symbol ：符号

​	用于创建一个唯一标识

### 类型转换

 转换主要指其他类型转换为number、boolean和string（其他类型要么值少，转换为该类型无意义或者使用场景不多）

需要注意的是，这里转换并不是真正的将值的类型转换为另一种类型，因为**原始值（基本类型字面量）是不可修改的**，不可能真正实现转换，转换的实质就是在内存区域开辟一个新的空间，创建数据类型为指定类型后将原有内容保持不变的放入

#### 转字符串

1. 调用toString()方法

   ​	将其他类型的数据原封不动的转换为字符串类型

   ​	存在缺陷：针对于Null、Undefined两个原始值类型，调用toString方法时，会因为无法读取数据类型内容（因为本身没有内容）而报错

2. 调用String函数

   ​	其他类型转换与toString()方法一样	

   ​	对于Null、Undefined，调用String函数，会直接返回Null和Undefined两个值。

补充：

​	调用x的y方法为：x.y；

​	调用y函数为：y（传参）；

#### 转数值

1. Number函数

   ​	将其他类型数据（纯数字）转换为数值类型，在针对于转换本身内容存放的非数值内容时（存在字母的字符串）（boolean值并不算，因为本身底层就是1、0），会转换为一个NaN，如果是空值则转换为0（Null，' ' ）

2. 针对字符串专门转换的函数

   ​	paresInt() ：转换为整数

   ​		按照从左到右的顺序依次访问字符串中的每一个字符，如果是数字，则成功转换为数值，并继续往下访问，直到访问完字符串或遇到非数字的字符（包括小数点）时，停止转换，丢弃后面所有的字符（如果后面还有字符的话）；如果开头就是非空的其他类型字符，则返回NaN，开头为空格和正负符号时，正常显示数值（负号保留）

   ​	paresFloat() ：转换为浮点数

   ​		原理一致，但遇到小数点（单个，多个则截断）还会往下读取

#### 转布尔值

Boolean()函数：对于空的、错误的都为false，其余为true ，对象一般都为true

以上转换都属于显示转换或强制转换

## 运算符（操作符）

  可以对一个或多个值（操作数）进行运算

### 算术运算符

​	+、-、*、/、%、**（加减乘除取余幂）

​	/ ：但除不尽时，会返回一个近似值，当除以0时，返回一个Infinity

​	对于除字符串加法的所有算术运算都是先将其他类型转换数值运算（隐似转换）后继续运算（可以实现类型转换）

​	字符串加法：拼串：将非字符类型的数据转换为字符串类型，然后连接起来。（可用于转换为字符串）

### 赋值运算符

​	将赋值运算符的右边的值赋值给左边的变量（不能更改顺序），只有左边的变量才是变量，而右边出现的变量是被当做值来看待。

​	=、+=、-=、*=、/=、%=、**=

​	空赋值：??=  当左边变量为Null、Undefined时，才会将右边的值赋值给左边变量

### 一元加减运算符

​      \+ ： 正号,不会影响数值的符号位

​      \- ：负号,对数值进行符号位取反

​      当非数值类型的数据进行正负运算时，会先转变成数值类型，在进行计算（可用于类型转换）

### 自增自减运算符

​	++ ：自增运算符，有前置和后置，前置先加再用，后置则先用后加

​	-- ：自减运算符，用法与自增一致。

### 逻辑运算符

​	对非Boolean类型使用逻辑运算符时，会自动转换为Boolean类型后再运算

​	逻辑非 ：！

​		假成真，真成假

​		可以实现其他类型转Boolean（！！）

​	逻辑与 ：&&

​		全真为真，有假为假；（找false，有false为假，没有为false）

​		短路：当&&左侧值为假时，发生短路，不会再去计算和判断右侧值，返回左值（逻辑与返回原值）

​		返回原值：当进行逻辑与和逻辑或时（Boolean和非Boolean运算都一样），其返回值并不是Boolean类型的值，而是返回左值和右值两个中的某一原值；

​		       原则：当左值为真时，返回右值；左值为假时，返回左值

​	逻辑或 ：||

​		全假为假，有真为真；（找true，有true为true，没有为false）

​		短路：当||左侧为真，发生短路，不会计算和判断右侧值，

​		返回值原则：当左值为假时，返回右值；左值为真，返回左值

### 关系运算符

​		检查两个值之间的关系是否成立，成立true，不成立false

​		 当存在非数值类型转换时，会先将非数值类型转换为数值（通常情况下）类型，再进行比较

​        	两个字符串进行比较时，按照Unicode编码（包含了ASCII码，因此比较字母啥的可以按照ASCII来比较）来一次比较每个字符，先大为大

​        	当像比较两个字符串中数的大小时，应该将其中一个字符串转换为数值类型，摆脱两个字符串类型比较的规则

​	>、>=、<、<=

​	==、!=：相等与不等

​		 null 与 undefined进行相等比较是为true

​        	NaN出现在关系运算符中，都显示false(NaN与所有值都不等，包括他自身)（NaN出现在关系运算中，结果只会是false）。

​	===、!==：全等与不全等

​		再发生不同类型数据比较时，不会发生类型转换，因此，不同类型数据在证明是否全等时，都是fasle，证明不全等时，true

### 条件运算符

​	表达式 ？ a : b ：表达式为真，执行a，为假执行b

### 运算符优先级

 	优先级表：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Expressions_and_operators

​      	使用过程中，如果不知道谁的优先级高，用括号将你想要执行的顺序括起来就行，优先级直接拉满。

## 流程控制

### 	代码块

​		使用{ }括起来的JS代码，将JS代码进行分组，不影响执行顺序。同一组代码块内的内容，要么都执行，要么都不执行

​		let与var声明变量的区别：

​			let声明变量有块作用域，只能在其出现的{ }中产生作用，推荐使用

​			var声明变量无块作用域，可以实现跨不同{ }产生作用，

### 	流程控制语句

​		控制语句执行顺序

#### 		条件判断语句

​			1.if语句 
​				if(条件表达式1) { 代码块1 }

​				当条件表达式1为真时，执行代码块1中的JS代码，否则将不会执行

​				当没有{ }进行约束时，if语句默认与最近（下）的一条JS代码匹配，不会影响到其他JS代码。

​			2.if -else语句

​				if语句+else { 代码块2 }

​				当条件表达式1为真，执行代码块1，为假执行代码块2

​				else语句与最近（上）的if语句进行匹配

​			3.if-else if-else语句

​				if-else语句中间插入一个或多个else if（条件表达式2）{ 代码块3 }

​				当条件表达式1为真时，执行代码块1中的JS代码，为假，则判断第一个else if语句的条件表达式2，为真则执行代码块3，为假则继续判断吓一			条else if 语句，直到所有的else if 语句全部完成后，执行else中的代码块2.

​				但有一个代码块被执行后，就会停止执行后面的语句，跳出整个语句

```
if(...) {
	....
}
else if(...) {
	...
} 这里一定一定不要加分号，不然会将整个if-else语句割裂，产生错误
...
else {
	...
}
```



#### 		条件分支语句

​			

```
switch(表达式) {
	case (表达式) :
		代码块
		break;
	.....
	default ：
		代码块
}
```

​		执行顺序 ：将switch中的表达式依次与case中的表达式进行全等比较，如果相同，则从该case为开始，从上往下执行所有代码（没有break的干扰下），如果存在break并执行到时，则停止执行后续代码并跳出switch。

​		default：当所有case都与switch的表达式不匹配时，执行default中的代码块，default可以放在任意位置，但要加break，不然还是从下到上继续执行。

#### 		循环语句

​			重复执行某一段代码

​			要求存在三种情况避免死循环：
​				初始化表达式

​				条件表达式

​				更新表达式

​			推荐死循环写法（部分场景必须用到死循环）：

​				

```
while(1){
	循环体
}
for(;;) {
	循环体
}

```

​			1.while语句

```
while(条件表达式) {
	循环体
}
```

​				执行顺序：

​					当条件表达式为真时，执行while中循环体的代码，执行完后继续判断条件表达式的结果....，假则跳出循环

​					当条件表达式恒为真时，发生死循环

​			2.do-while语句

```
do {
	循环体
}while（条件表达式）
```

​				执行顺序：

​					先执行do中的循环体，再判断条件表达式的真假，真继续执行do中循环体，假则跳出循环

​				与while的区别：

​					while ：先判断，再执行

​					do-while ：先执行，再判断，保证循环体至少执行一边。 

​			3.for语句

```
for(初始化表达式;条件表达式;更新表达式) {
	循环体
}
```

​				执行顺序：

​					先执行初始化表达式（let（推荐）、var生成的变量作用范围不同。只会执行一次），然后再判断条件表达式的真假，真则执行循环体后				执行更新表达式，然后继续判断条件表达式，执行或跳出。

​				三个表达式都可以省略，但要保留';'分隔。

​			循环嵌套 ：
​				外层循环一次，内层循环一个完整周期

​			break和continue：

​				break ：跳出switch语句和循环，只会影响最近的switch和循环

​				continue ：跳过本次循环，执行下一次循环

## 对象

​	JS中的复合类型数据，无序的存放不同类型的数据（相当于容器）(并不存在作用域)；

​	存放的数据称为属性（属性名和属性值，对象中属性的值可以是任意属性类型，也可以是一个对象（函数）），

### 	定义 

​	let 变量名 = （new）Object();

​	let 变量名 = { 属性名 ：属性值 ，....}；（对象的字面量，类似数据结构）

​	typeof检查对象返回object

### 	创建属性

​	变量名.属性名 =属性值 （当属性名与属性值相同时，单写一个就行）

​	属性名可以有任意字符组成（属性名在底层是属于字符串），但存在特殊字符时，使用变量名[属性名] =属性值来创建，取出和存储的方式一样

### 	删除属性 

​	delete 对象名.属性名 

​	当读取一个对象中没有到属性名时，并不会报错，而是返回undefined	

### 	symbol

​	创建唯一不易见的属性

​	使用符号类型（symbol）作为属性名，添加属性(一般情况下，不希望被别人看到和更改)

​	怎么实现：当使用[]去操作属性名时，里面可以是类名，变量名，对于变量名借助[]操作属性名时，本质是按照变量中的值操作

​		因此指定一个变量存放符号类型数据，然后再通过使用[变量名]来使用变量中的值去创建属性时，就是使用symbol创建属性

### 	枚举属性

​	语法 ：for(let 枚举名 in 对象名) { 语句 }

​	枚举过程中，会依次将属性名赋值给枚举名（也就是说，枚举名会暂时成为属性名，），但是symbol创建的属性名就无法被枚举

### in 运算符

​      "属性名" in 对象 :表示检查一个对象里面有没有这个属性,存在返回true，不存在返回false

​	不区分属性是否在对象的自身区域还是对象的原型区域，有就行，没有就不行

### 对象内存结构 

​	变量名、变量值按照键值对表形式存放在栈内存中，变量值存放引用，指向存放在堆内存中的对象 （属性名和属性值），属性名和属性值成键值对表存	放在堆内存，属性值可以是直接存放的原始值或者是引用，用来指向存放在堆内存的或另一个对象

​	对于字符串的存储，引擎实现时可能将其存放在特定位置，然后实现逻辑上的直接存放（可能存在跳转到特定位置拿取）

​	两个对象在进行全等或等于比较时，是比较两者的地址

​	对象存储属性、方法划分：

​		1.对象自身区域

​			 通过对象自身创建的属性

​          		通过在创建对象的类中，使用x = y的形式创建的对象

​		2.原型对象区域（prototype）	

​			对象还有一些属性，存放在其他对象中（原型对象）（原型对象与对象是两个独立的对象）

​			 1.在类中，以xxx（）{}创建的方法

​         		 2.主动添加到原型对象的属性和方法	

对象中有一个隐藏属性（__proto__），存放了指向其原型对象的引用

​        原型对象也会负责存储对象属性，当进行访问对象属性时，会优先访问存放在对象自身区域的属性，如果没有找到要访问的属性，才会去原型对象中进行查找

​        如果当存放在对象本身和原型对象的属性重名，则会执行对象本身区域的属性

### 可变类型 

​	对象的可变性是指对象的属性可以增加、删除，属性值的修改，并不指存放变量值地址的内容发生改变

### 改变量和改对象

​	修改一个变量时，是新开辟一块空间存放新值，并不影响原来的值，也不会影响其他变量

​	修改一个对象时，会导致指向该对象的所有变量发生改变

​	因此，在使用变量声明对象时，常常会因为某些原因导致变量指向内容发生改变，不知道变量谁指谁了，提高代码复杂度

​        常用const去修饰存储对象的变量，禁止在为对象变量进行赋值操作

### 对象方法 

​	当对象的某个属性是函数时，称这个函数是该对象的方法，调用该函数就是调用对象的方法		

### window对象

​        window是一个对象， window对象代表浏览器的窗口（由浏览器提供），通过该对象可以实现对浏览器窗口的各种操作

​        window对象的属性可以通过window.来访问，也可以直接访问。创建一个函数可以看成创建window的方法

​    	还负责存储JS的内置对象和浏览器的宿主对象

​        var一个变量本质上就是在window上创建一个属性

​	在没有使用let、var、const声明一个变量时并赋值时，会直接在window对象中创建一个相同属性名和值的属性，等同于window.d=10（var d =10）

​        使用function创建的函数，相当于在window中创建了一个方法。

​        let一个变量并不会在window创建一个新属性，但let生成的变量一定存在，存在于一个秘密的地方

​        当let和var声明的变量名相同时，不会报错，但会优先访问let声明的变量

​	var声明的变量虽然没有块作用域，但因为函数存在函数作用域，因此在函数使用var声明一个变量时，超出函数后就消亡。

## 函数

### 	定义 

​		一个特殊的对象，可以存放语句，需要时进行调用来执行语句。

​		typeof检查函数类型时，返回function

### 	声明

​		function 函数名() { 语句 }; 调用：函数名()；

​		const 变量名 = function () { 语句 }; 调用：变量名()；

​		箭头函数 ：const 变量名 =() => { 语句 }/语句（一条）;调用：变量名()；

### 	参数 

​		形式参数

​			在函数定义时，可以设置多个不同的形参，

​			在函数中定义形参时，指定义了形参但并未对其赋值

​		实际参数

​			调用函数时，传递给函数的多个参数就是实参，实参会为对应位置的形参赋值（传递过程中，将实参存放的地址或引用进行传递）

​		形参与实惨数量

​			当形参数量大于实参时，多余形参将不会被赋值

​			当形参数量等于实参时，形参与实参进行一一对应，然后赋值

​			当形参数量小于实参时，多余实参将不会赋值。

​	因为JS中，参数是没有类型可言的，所有参数可以被赋予任意类型的数据，会在编写代码中造成意料之外的错误，因此传参过程中，应当进行强制转换来避免这些错误

​		对象参数

​			就简单的一个参数就是对象

​			当函数形参默认是一个对象时，该对象会在调用函数时被创建，函数结束时消亡，因此连续调用该函数时，看起来函数默认参数创建的对象是同一		个，但每当函数结束后就会消亡，如同转世一样。又怎么可能是同一个呢，转世后的人早已不是当初的人了

​			当然如果函数默认参数是指向一个已经创建的对象，这个对象本来就存在，连续调用并不会导致对象的消亡。对象也不会转世，对对象的修改也会		一直保留下来。

​		函数参数

​			就简单的一个参数是函数

​		箭头函数参数

​			一个特殊的地方：当箭头函数形参就只有一个时，可以省略括号（let a = a => {}），且不能为函数参数设默认值

### 	函数返回值

​		函数使用return来实现返回函数值，返回值可以是任意类型的数据

​		当没有return时，接受一个函数的返回值，会显示undefined。

​		函数一旦执行return语句，函数立即结束

​		箭头函数返回值

​			当一个箭头函数就一个返回语句时，可以不用写{ }和return，直接将返回内容写入就行

​			当一个箭头函数只有一个语句且要返回一个对象值时，应当使用（）将其包裹，让解释器知道里面的内容是返回值而不是函数语句

### 	作用域

​		一个变量起作用的区域

​		作用域生命周期

​			被创建开始到销毁之间。

​		全局作用域

​			网页被创建开始，到网页关闭结束

​			全部直接写在script标签内都属于全局变量，全局变量可以在任意位置被访问到

​		局部作用域

​			块作用域

​				代码块被创建时开始，代码块执行完毕时销毁

​          		      所有直接写入代码块的都位于块作用域中，块作用域的变量都属于局部变量，只能在所属块中被访问

​			函数作用域

​				 函数调用时产生，执行完毕销毁

​          			所有写入函数的都位于函数作用域中，位于函数作用域的变量都属于局部变量，只能在所属函数中被访问

​        			  每一次调用函数时，会产生新的作用域，互不影响

​		作用域链 

​			解决当访问一个变量时，解释器该如何去寻找一个变量

​			当开始访问某一个变量时，JS解释器第一步首先在所属块中开始查找，找到了就返回，如果没有找到，则往上一层块中进行查找，找到返回，没找到重复上一层块进行查找直到找到或找完所有父级块，返回找到的值或报错

​			查找原则 ：就近原则，不会访问同级块，函数在被创建时就确定了作用域，在任意位置调用按找函数块开始不断往上查找

### 	提升

​	 变量的提升：（声明提升）

​        使用var声明变量时，声明变量的代码将会被最先执行（只会声明，不会赋值）,

​        怎么理解先执行？：

​          指将所有的var 声明的变量改变一下位置，会在最开头先使用var声明出哪些变量，但并不赋值，只会在原有位置进行赋值操作

​      函数的提升：（值提升）只适用于函数名开头的

​        在构建函数时，可以在构建函数之前就可以调用函数实现函数中的语句（在其他代码执行前被创建）

​      let、const、class提升：

​        使用上面的声明变量或类时，会发生一个提升，虽然会提示暂时性死区（TDZ），但本质还是因为提前了的同时，JS解释器禁止在声明前进行访问

​      为什么提升 ：

​        告诉JS解释器，有什么变量名和函数名，你要好准备工作

### debug

​	设置断点 

​		在想添加断点的地方加上：bebugger

​		控制台源代码增加

### 立即执行函数

​	生成一个作用域块，用来隔绝var声明的变量，防止后续变量名冲突而产生变量名污染

​	对于let，直接使用{}就行

​	立即执行函数表达式（匿名函数）（IIFE）

​	语法 

​		声明 ：( function() { 语句 } )

​		匿名函数就是没有函数名，表达式则是将匿名函数用括号括起来。

​		调用 ：( function() { 语句 }() ) 或者 ( function() { 语句 } )()

​		注意

​		当两个匿名函数连写并且没有使用分号隔开时，会引发JS解释器的误判（JS解释器忽略换行），会理所当然的认为两个括号时一个函数调用，将前面的	匿名函数当成函数名，但实际上这是一个函数体，而且并没有函数名这么奇怪，因此会返回前面括号并不是函数的bug，此时使用分号隔开能避免这类情况的	发生。

### this

​	普通函数的this

​		this是函数的一个隐藏形参，指向某个对象，根据调用方式不同指向不同（但本质还是指向调用该函数方法的对象）

​		函数形式：指向window

​		方法形式：指向使用该方法的对象

​	箭头函数的this

​		箭头函数的this是固定指向一个对象，并不会因为调用方式的改变而发生改变，他会在生成时候就与外层作用域的this相绑定

​	构造函数中，this是新建的对象

### 封装函数

​	将一个功能封装成函数，方便调用

### 回调函数

​	当一个函数作为参数传递时，这个函数就是回调函数（callback）（让接受函数在自身中调用回调函数）

​	可以动态的实现不同语句

### 高阶函数

​	当一个函数的参数或返回值是函数时，那么称这个函数是高阶函数

​	将一个函数作为参数或返回值，可以实现对另一个函数动态传递代码

​	针对于OCP原则，修改一个已经存在并被他人使用的函数，是不正确的，因此应当避免函数的写死和为增加功能而修改函数的行为

### 闭包

​	内部函数访问外部函数中的变量

​	作用 ：隐藏一些不希望被他人访问的内容

​	实现：

​		存在函数嵌套

​		内部函数访问外部函数的变量

​		外部函数返回内部函数	

​	基本原理 ：

​		函数在创建时就确定了函数作用域（也称词法作用域）（也包括作用域链），与函数调用位置无关，只与函数所在位置相关

​		闭包就利用了词法作用域来实现隐藏功能

​	生命周期 ：
​		外部函数调用时就会产生，每次外部函数被调用时都会产生一个新的闭包

​		当内部函数丢失时才销毁（内部函数被垃圾回收）(简单的例子，当原本指向内部函数的变量指向其他地方时，内部函数就丢失了)

​	因为每调用一次外部函数，就会生成一个全新的，结构相同的相互独立的闭包，会占据较大空间，很容易空间浪费

​	因此大规模隐藏不想被访问的变量时，可以使用类（静态属性修饰），而不会使用闭包，只有小规模才会使用闭包

### 递归

​	调用自身的函数就是递归函数，与循环基本一致

​	核心 ：将一个大问题拆分成小问题，解决所有小问题来解决大问题

​	两个条件（必要） ：
​		1.基线条件 ： 递归函数的终止条件

​		2.递归条件 ： 如何拆解问题

​	与循环的区别 ：
​		递归思路简单，注重于如何拆解问题，不需要分析问题的实现，但是在递归中会不断创建新的函数作用域（占用内存空间），会导致程序运行速度慢；

​		这就显得循环在实际开发环境中，使用场景高于递归，递归只会在处复杂问题上，才会采用递归

### arguments

​	函数中隐藏的类数组元素，用于存放函数调用传递的实参。typeof检查返回object

​	可以使用length求出arguments的长度，可以遍历arguments来访问存放的实参，但是不能使用数组的方法（没有指向Array.prototype）

​	箭头函数没有arguments

  存在问题 ： 当拿到别人的函数时，不知道该不该传参； 不是一个数组，不能使用数组的方法

### 可变参数

​	定义 ：...参数名

​	定义函数时，可以指定函数参数为可变参数，可变参数可以接收多个实参并将这些参数存放到一个数组中 （与arguments作用一致）

​        区别（arguments） ：

​        1.可变参数的名字可以自己设定

​        2.可变参数是一个数组，可以使用数组的方法

​        3.可变参数可以配合其他参数一起使用（但是可变参数必须最后面写）

### 函数补充 

​	调用 ：
​		函数名.call()

​			传递参数 ： 第一个实参为函数this指向，后面的参数为实参，一一列出

​		函数名.apply()

​			传递参数 ： 第一个实参为函数this指向，后面的参数按照数组形式给出

​	bind() :

​		一个函数方法，用于创建一个新的函数

​		参数 ： 第一个参数为新函数的this指向（固定this，无法修改），后面参数为新函数的实参， 用来固定实参，调用新函数传递实参时，先传固定实参，再传调用时的实参

​	三个方法都可以用于修改一个函数的this指向，但是由于箭头函数没有this，因此三个方法均不能修改this指向

严格模式 
	正常模式（非严格模式）：
		JS解释器语法检查并不严格，尽量不报错

​	严格模式 ：

​		JS解释器语法检查严格，会提前报出一些小问题

​		使用：在向增加严格模式的代码区域中，开头增加 "**use stickt**" 字符串



## 面向对象编程 

### 	定义

​		对现实事物进行抽象（获取部分信息），将事物的数据功能转化为对象的属性和方法。

​		编程世界中所有事物都有对象构成，所有操作都通过对象完成；完成任何事情时都需要先找到对象

### 	类

​		定义

​			是对象的模板，也是一个特殊的对象，创建多个相同类型的对象，通过类创建出的对象，这个对象成为类的实例

​			由同一个类创建出的对象属于同类对象；

​			可以通过 “对象名 instanceof 类名 ”来检查该对象是否由这个类创建出来的，是返回true，否则false。

​		语法：

​			创建类：

​				class 类名 { ... }

​				const 类名 = class { ... }

​			创建实例 ：

​				const 对象名 = new 类名();

​		属性 ：

​			在类中创建的普通属性属于实例属性，只能通过实例进行访问

​			而使用static修饰的属性属于静态属性（类属性），只能通过类进行访问

​		方法

​			写法 ： 方法名 = function(){...}（可以显示在实例中） 或方法名(){...}（不能显示，但仍然可以调用）

​			方法不会显示在创建的实例中，但是实例可以对方法进行调用（this还是指向调用他的对象）

​			整体和属性一样

​		构造函数

​			constructor()（构造函数、构造方法）：

​			创建一个实例时，后面的new 类名（）相当于调用constructor方法（因此，称new 类名（）是一个构造函数），constructor方法会接受new 类名（）的实参，并通过方法内的语句（this）将实参赋值给属性

### 	面向对象的特性	

​		封装——安全性	

​			 对象负责数据安全、存储属性

​        		但是直接添加到对象中的属性并不安全，可以任意的被修改

​        		实现封装：

​          			私有化数据

​					将需要保护的数据设置为私有，只能在类内部进行使用（在属性名前加#）

​					 通过构造函数设置私有属性时，必须先在构造函数外提前声明私有属性，不能在构造函数内进行声明为私有属性,再通过构造函数对私有					属性进行赋值

​          			通过getter（返回）、setter（获取参数修改数据）方法操作属性

​					可以控制属性的读写方式,可以在方法中进行验证

​       				调用和方法写法：

​						p1.getName();p1.setName(name);	

​						getName() { return this.#name }; setName(name) { this.#name = name };

​						p1.name ; p1.name = '...'

​						get name(){  }; set name() {  };															

​		多态——灵活性

​			同一接口，不同实现

​			父类定义了一个方法，不同子类重写后有不同功能，调用时不用管具体是哪个子类，直接用父类接口调用就行.

​		继承——扩展性

​			可以使用extends来完成继承

​       		 当a extends b时，a将会拥有b的相同结构（属性和方法）（b是父类，a是子类）

​      		  通过继承可以减少重复的代码，可以在不修改一个类的前提下对其进行扩展

​			扩展：

​				在子类中，可以通过创建父类同名方法进行重写父类方法，如果想要在重写时引用父类的方法 ：在方法中可以使用super来引用父类中的方法（在使用父类的方法下，又可以进行新增独立的功能）：super.方法（）;

​				子类重写构造函数时，必须在构造函数的第一行写上super（）（可以不在第一行，但必须在调用this的前面）来表示调用父类的构造函数，如果想要实现使用父类的属性，在super中加参数就可以实现使用父类的构造函数声明属性

### 	原型

​		存放数据 ：

​			1.实例中的数据（属性和方法）

​			2.构造函数（constructor）

​		原型对象也是对象，也划分两个区域：自身属性和原型对象区域

​			__ proto__ ：

​				对象中的属性（对象的隐式原型），指向构造函数的prototype

​			prototype ： 

​				构造函数中特有属性，指向构造的原型对象

​			一个实例的__ proto__ 将会指向构造函数的prototype

​		注意点：

​			一个函数的构造函数是function

​			一个普通对象的构造函数是Object

​			子类原型的__ proto__  将会指向父类原型的prototype.

​			let a = Object.creat(b) :指将a的__ proto__ 修改为指向b

​		访问原型对象 ：

​			1.对象名.__ proto__ :可以使用，但是不能为其赋值！！！！,赋值就改变了原型

​				补充 ：一般情况下，以下划线开头的属性都是不希望被访问和修改的隐藏属性，这里带了两个下划线，就更加不想你知道了

​			2.Object.getprototypeOf(对象名) ：相对安全，只读取

​		原型链 ：
​			 原型对象也有原型，从而构造成一条原型链，根据其对象的复杂程度的不同，其原型链的长度也将不同

​			 因此，读取对象的属性时，读取顺序为

​			先在对象自身寻找属性，如果有，则读取，没有就往对象的原型上查找，找打访问，没有继续往下一个原型找（原型链）...直到找到或Object对象	的原型，返回undefined

​		与作用域链的区别：      

​			作用域链 ：找变量，找不到给错误

​      		  原型链 ： 找属性，找不到给undefined

​		原型的作用 ：
​			原型就是一个公共区域，写在里面的属性和方法可以被处于同一条原型链的对象所访问

​		 	可以将**一个类的实例**中的所有公共属性（方法）写入原型对象中，此时只需要在类中创建一个对象就可以完成所有实例的需求、

​		JS中，继承就是通过原型实现的，因此，继承又称为原型继承，当继承时，子类的原型就是父类的一个实例

​      	JS中，一个类的原型与由其创建的实例的原型是同一个原型对象

### instanceof、hasOwn

​	instanceof 

​		检查一个对象是某个类的实例，本质上按照原型链上去寻找该对象的原型链上是否出现了类的prototype，出现了说明该对象是这个类的实例，返回true，否则返回false	

​		语法与in运算符一致：对象 instanceof 类。

​	hasOwn ：
​		语法：Object.hasOwn(对象名，'属性名')

​		主要是检查属性是否在对象的自身区域，是返回true，不是为false，取代hasOwnProperty方法。

​	hasOwnProperty :
​		语法：对象名.hasOwnProperty('属性名')

​		功能与hasOwn一致，

​		缺陷在于，当使用Object.create(null)来创建一个对象并使其原型指向空时，再来调用这个方法将会报错，（hasOwnProperty在Object的原型中）

​		而对于hasOwn来讲，无论对象怎么样创建，都并不会报错，并根据情况给出正确答案

### 旧类

​	早期直接通过函数（构造函数）来进行定义类

​	函数调用方式：直接调用（函数名（））和通过new运算符来调用（new 函数名（）），前者就是普通的函数，后者就是构造函数

​	构造函数就相当于类的constructor，因此，定义属性上采用this.属性名来定义

​	针对于要写入原型区域的方法，采取直接写入的形式 ：构造函数名.prototype.方法名 = function()  { ... }(属性一个道理)

​	实现静态方法和属性：

​		构造函数名.static方法名/属性名 = function() {} /属性值

​	实现两个构造函数的继承关系

​		b.prototype = new a()：b继承于a（一个构造函数的原型指向另一个构造函数的一个实例）

​	由于通过构造函数所声明的类并不能一次就能生成完整（原型区域的方法、静态属性方法...），因此，一般构造函数整体放入立即执行函数中，最后在写完所有属性后，返回构造函数（可以不返回），使用一个变量存放返回值，后续可以通过这个变量来创建对象

### new运算符

​	使用new运算符调用函数时，new会完成下面的事情：

​		创建一个对象；

​		使对象的__ proto__指向构造函数的prototype；

​		使用实参来执行构造函数时，会将函数中的this指向新对象

​		当为构造函数设置返回值时，如果返回一个非原始类型数据时，那么这个构造函数将会将该值当作该构造函数的返回值（此时构造函数就失效了，除非必要情况不返回非原始数据类型）；如果返回一个原始类型数据或没有返回值时，默认将创建的对象返回。



### 面向对象总结 

​	面向对象，就是所有操作都通过对象完成

​	面向对象步骤 ：
​		找对象

​		操作对象

​	学习对象：
​		明确这个对象是什么，有什么用

​		该如何获取这个对象

​		如何使用对象的属性和方法

​	 对象的分类 ：

​        	内建对象：

​        	 	 由ES标准提供的对象（基石）

​          		Object、function、String、Number

​        	宿主对象

​          		由浏览器提供的对象

​          		BOM（操作浏览器）、DOM（操作网页）

​        	自定义对象

​          		有开发人员创建的对象

## 数组

​	是一个复合类型的数据，有序的存放不同数据类型的数据，存放在数组中的数据被称为元素

​	数组中每个元素都会有唯一的索引（一组大于等于0的整数），可以通过索引来完成对数据的操作和访问

​	使用typeof检查数组类型时，会返回object类型

### 	声明

​		 let 变量名 = new Array(元素);

​		let 变量名 = [ 元素 ]（推荐使用字面量，更加清楚）

### 	读取数组

​		数组名[索引] ：读取数组中该索引上的元素

​		如果读取的索引上没有存放元素时，返回undefined

### 	数组长度

​		数组名.length ：给出数组的长度（长度为最大索引+1）

​		可以通过arr[arr.length] 来为数组的最后一位赋值

​		修改length时，如果length增大，数组多出相应数量的空元素；变小，则会删掉超出部分的元素。

### 	非连续数组 

​          	存放在数组中的元素之间有空的数组，（）应该避免使用

### 	遍历 

​		for循环遍历

​		for-of语句

​			用于遍历可迭代对象

​		语法 ：

​       		 for(变量名 of 可迭代对象名) { 语句}

​        		循环次数由数组中元素个数决定

​       		 每次循环中，会将数组元素依次赋值给变量

​       		 唯一不足只能从前往后遍历

### 	方法

​	非破坏性方法：

​		不会影响原数组，只会返回一个新的数组

​	破坏性方法 ：

​		影响整个数组

​	静态方法：

​		Array.isArray() ：

​			检查参数是不是数组，是返回true，不是返回false	

​		Array.of() ：

​			返回一个数组，将实参转换为数组的元素（按照数组顺序）

​			跟Array()区别在于单参数（整数），Array.of将会生成单元素的数组，而Array则会生成参数相对应的空值元素

​		实例方法：

​		非破坏性方法:

​			at() :

​				给定一个参数，将参数作为索引来返回数组中该索引存放的元素

​				正数 ：从前往后开始找索引（索引等于参数）

​				负数 ： 从后往前找这个负数的绝对值（从-1开始）（索引就是等于负数加arr.length）	 

​				当正数和负数超出数组长度时，返回undefined			

​			concat() ：

​				合并两个或多个数组(原封不动的将数组所有元素粘到另一个新数组)，并返回该新数组

​				数组名1.concat(数组名2,......) 将实例和参数中的数组按顺序（1，2...）粘到另一个数组中

​			indexOf() ：

​				返回正向查找指定元素第一次出现的索引

​				两个参数 ：a ，b （a表示要查找的元素，b表示索引开始的位置（正前负后），整体范围为 ： b~最大索引）

​				默认情况下，b不写和 b<-arr.length时，b就是0。当b>=arr.length时，不会寻找数组，返回-1。

​				如果指定元素无法找到，返回-1,查询NaN时，也会返回-1；

​			lastIndexOf() ：

​				返回反向查找（向前查找）指定元素最后一次出现的索引

​				两个参数 ：a ，b （a表示要查找的元素，b表示索引开始的位置（正前负后），整体范围为 ： 0~b）

​				默认情况下， b<-arr.length时，返回-1。当b>=arr.length和b被省略时，会检查整个数组来找到最后出现的指定元素；设置0时只查第一位

​				如果指定元素无法找到，返回-1,查询NaN时，也会返回-1；

​			join() ：

​				将数组中的元素连接成一个字符串并返回该字符串

​				一个参数 ：a 决定元素之间的分隔符

​				a的取值 ：

​					没有定义时，使用 ','隔开；' '则是'-'隔开，其余情况按照a的内容进行隔开

​			slice() ：

​				将数组中的一块区域复制出来，并返回包含被复制元素的新数组

​				两个参数 ：start 和 end (两个索引，前闭后开)

​				start特殊取值：

​					正前负后，当start 的绝对值大于数组长度和start = 数组长度时，将不会进行提取元素，但没复制时，按0处理

​					当end <start时不进行提取，当end >= 数组长度或没赋值时，按照数组长度处理

​			forEach() : （数组在使用时，长度已经固定，无法更改）
​				遍历一边数组元素，使每次数组元素都执行一次参数中的回调函数，当元素为空时，跳过该元素

​				两个参数：回调函数 ，执行回调函数时使用的this（可省）

​				回调函数参数 ： 当前执行的数组元素， 当前元素索引 ， 数组本身

​				返回undefined

​			filter() ：（数组在使用时，长度已经固定，无法更改）

​				返回一个新的数组，数组中存放原数组中可以通过回调函数的元素

​				两个参数：回调函数 ，执行回调函数时使用的this（可省）

​				回调函数参数 ： 当前执行的数组元素， 当前元素索引 ， 数组本身

​				当回调函数返回true时，存放该元素，false则跳过该元素

​			toSort() ： 跟破坏方法使用一致，但不会破坏原数组，返回一个排序好的数组

​			map() ：（数组在使用时，长度已经固定，无法更改）

​				返回一个新的数组，数组中存放原数组中元素通过回调函数运算后的新元素，如果设置回调函数不返回，则默认返回undefined

​				两个参数：回调函数 ，执行回调函数时使用的this（可省）

​				回调函数参数 ： 当前执行的数组元素， 当前元素索引 ， 数组本身

​			reduce() ：（数组在使用时，长度已经固定，无法更改）

​				返回一个单值。单值等于设定的初始值 + 数组中所有元素的和

​				两个参数 ： 回调函数 ，初始值

​				回调函数参数 ：上一次运算的结果 ，当前元素的值，当前元素的索引

​				当进行第一次运算时，如果设置了初始值，则上一次运算的结果就是初始值，如果没有设置初始值，则默认索引为0的元素是上一次运算结果，当前元素的值和索引将会指向第二个数组元素

​				如果对一个空数组执行reduce时，如果不设置初始值，则报错，设置则返回初始值

​		破坏性方法：

​			push() ：

​				一个或多个参数 ：a、b、c...

​				在数组最后增加一个或多个元素 ：a、b、c...，并返回修改后数组的长度；

​			pop()

​				删除数组最后一个元素并返回被删除的元素；如果数组为空，返回undefined

​			shift()

​				删除数组中的第一个元素并返回被删除的元素

​			unshift()

​				一个或多个参数 ：a、b、c...

​				在数组前面增加一个或多个元素，并返回修改后数组的长度

​				 当一次传多参和单个单个将指定参数传入时，参数在数组上的顺序不同。

​			splice()	

​				三种参数 ：start  number  a、b、c...	（参数二、三可省）

​				从索引start（正前负后）开始，删除number个元素，并插入a、b、c...个元素。

​				start >= arr.length或number = 0时，表示不删除元素，增加元素（参数三有的情况下）。start < -arr.length时取零，

​				number取负数和0时都不进行删除，取正数时删除相对应元素，无限删可取Infinity

​				a、b、c...没有时只删不加

​				返回一个包含被删除元素的数组，如果没有删除的元素，则返回空值

​			reverse()

​				一个参数 ：数组

​				将数组中的元素进行逆转，并返回逆转后的数组

​			sort() :
​				对数组进行排序，并返回排序后的新数组（默认情况下，将数组的元素看成字符串，通过Unicode编码来按照升序排列，）

​				参数 ： 一个回调函数（决定排序是升序还是降序）（可以省略）

​				由于sort是默认将元素看成字符串，在比较数字是会出现10<2的情况，此时需要通过设置回调函数来改变默认情况 

​				回调函数的设置 ： （两个参数 : a ，b 代表要比较的元素）

​					根据元素的比较情况后返回值的不同，决定两个元素的排列顺序 ：1排后，-1排前，0保持不变 （排序数字时可以整体返回 a-b或 b - a）

​				

### 数组去重

​	破坏

​		注意点在与删除一个元素后，后面元素会补位从而会导致存在元素无法进行判断情况，需要 -- 来判断后一位

​	不破坏

### 数组排序

​	冒泡排序

​		最慢的排序，面对数据量的大的就不合适了。比较相邻的两个数，根据大小关系和要求决定顺序

​	选择排序

​		取出一个数，然后将其他的数与之比较，根据要求交换顺序

​		直接找最小数索引然后交换取出的数和最小索引元素

### 对象的复制	

​	复制必须要产生新的对象

​	注意：原始值在内存中是唯一的，不可能出现两个相同的原始值（对于原始值来讲，拷贝不分深浅）	

​	浅拷贝

​		复制某个对象的一层，就开辟一个新的对象，但其中属性、方法还是指向原对象的属性，因此存在改一个对象从而影响两 个对象（外层相同，里层不同）

​		方法：

​			展开语法：...

​				枚举对象的所有属性，并将所有键值对返回到新对象中；

​				 将一个数组的元素展开到另一个数组中或作为函数参数。

​				会对重名属性、元素...进行覆盖，具体覆盖看谁前谁后，后盖前

​			Object.assign()

​				两个参数：target ，source

​				将source中的所有属性复制到target对象中，并返回修改后的target对象（存在重名时，发生覆盖）

​	深拷贝

​		完整的复制整个对象，在内存中开辟出一个相同属性名、方法的对象，虽然属性值还是指向同一个原始值（唯一性），但不存在改一个对象而影响两个对象。但是会影响性能，除非要求独立操作，不然就不会使用

​		方法：

​		structuredClone()（浏览器提供）

## 解构赋值

​	将对象或者数组中存放的属性和元素依次拿出进行赋值

​	数组解构 ：

​		使用 ： [] 来进行接受 。形如 ：[a,b,c,...d]（变量） = [1,2,3,4,5....];

​		将右侧数组存放的元素依次赋值给左侧定义的变量，当右侧变量多余数组元素时，多出变量为undefined，少于元素时，多出元素不进行赋值

​		但使用...d进行接受数组解构时，表示将剩余数组元素都赋值给d，并通过数组进行存储

​		解构时，可以为变量设置默认值 ： a = 10。当没有元素为其赋值时，取默认值，有则覆盖

​	对象解构 ：
​		使用"{}"来进行接受对象解构

​		对象解构时，会按照左侧变量的标识符在右侧对象中查找对应属性名，找到就复制，没有将不会被赋值（undefined）

​		在定义变量后，在进行解构赋值时，应加上"（）"

​		

```
let a,b,c,d;
{a,b,c,d} = {a : 1 , b : 2 };  此时JS解释器将会把{a,b,c,d}看作为一个代码块，对一个代码块进行赋值是不行的，会抛出错误
正确写法 ： ({a,b,c,d} = {a : 1 , b : 2 });

可以为变量取别名，赋默认值
{name : a = 10,age :b = 20} = {name : '孙悟空', age : 18};
为name取了一个别名a，会将对象的name属性值赋值给a...。可以通过访问a，b来打印孙悟空和18.
```



## 内置对象

### 	JSON

​		用于对象的序列化 ：
​			将存放在内存中的对象的转换为一个存储格式（JS中，对象序列化指将对象转换为字符串（也称JSON字符串））

​		序列化作用 ：	

​			作为数据交换的格式（将对象转换为字符串后，人和其他编程语言都可以识别字符串，从而使JS的对象在不同语言中传递）

​			编写配置文件

​		实现 ：

​			JS提供了一个工具类 ：JSON，可以实现对象转JSON字符串

​			静态方法 ：

​				stringify() ：将对象转换为JSON字符串

​				parse() ：将JSON字符串转换为对象

​			可以通过将对象转换为JSON字符串，然后再转换为对象来实现对象的深拷贝

​		编写JSON ：
​			JSON字符串只能是对象（{ }）和数组（[ ]），也就是说JSON字符串只能由{}、[]开头

​			JSON字符串属性名必须要使用双引号括起来

​			JSON字符串中的属性值、元素可以是 ：

​				字符串(必须双引号括起，防止其他语言无法识别)、整数（正常的Number）、空、布尔、对象、数组、

​			JSON字符串写法与对象类似，但是更加严格，如果属性是最后一个，则不能加','

### 	Map

​		用于存放键值对类型的数据 （可以将对象也看为存放键值对）

​		与object的区别

​			object的键只能由字符串和符号类型进行命名

​			map可以通过任意类型来进行命名键

```
创建map实例
let map = new Map();

添加数据 
map.set(key, value); 当使用字符串作为key来接受value时，应该使用引号括起让set知道这是key，否则会使用 ''来存放value

访问数据
map.get(key);访问实例map中指定key名

删除数据
map.delete(key)

检查是否存在某个键值对
map.has(key)

实例map存放的键值对数
map.size

map实例方法 ：
map.keys() ：获取map的所有键，顺序不变 （可以同过该方法获取全部的键）

map.values() ：获取map的所有value，顺序不变 （可以同过该方法获取全部的值）

map.entries() : 获取map的所有键值对
object使用非字符串类型数据，符号...进行命名属性名时 ：需使用[]修饰
[symbol] = 1; 
[{}] = 2;这里将会导致后续该对象调用任意对象都会访问2（在进行转换时将对象变为{}）
```

```
map转数组 map转换来的数组是二位数组（数组中的元素是数组） 
let arr = Array.from(map);
arr = [...map]; map中的每一个键值对都将转换为一个数组,key和value都将成为各自数组中的元素
因此，在遍历由map转换来的数组时，每次拿到的就是一个数组，存放了key,value
 
```

### Set

​	一个集合，用来存放不重复的数据 （底层上是一个map，只不过键和值都一样）(功能上与数组类似，可以使用Set存放不重复数据)

```
创建一个实例 ：
let set = new Set(); 可以传递一个数组来实现去重

访问数据数
set.size;

添加数据 
Set.add(value); 对于一个重复的数据，将不会继续添加重复数据

访问数据
Set并没有提供访问方法，推荐先转换为数组（from，...），再进行访问

检查数据
Set.has()
 
删除数据 
Set.delete
```

Math

​	一个工具类，提供一系列数学相关的常量和方法（静态）

```
常量 ：
Math.PI :圆周率

方法 ：
Math.abs() : 绝对值

Math.min() ： 求多个值中的最小值

Math.max() ： 求多个值中的最大值

port(x,y) : 求一个x的y次方

squrt() : 求一个数的平方

取整 ：
floor() :向下取整

ceil() ： 向上取整

round() ：四舍五入

trunc() ：舍弃小数

random() : 生成一个0~1的随机数（包括0，不包括1）
	生成一个x~y范围的整数 (怎么去设 就把0~1扩大m倍，加n得n~m，然后就是解方程了n = x;m+n = y)
	

```

### Date

​	表示所有的与时间相关的数据

​	时间戳 ： 指从1970年1月1日0时0分0秒到当前时间的毫秒数 计算机底层在存放时间时，都是采用时间戳存放

​	为什么使用 ：因为年月日时分秒的进制都不同，存储麻烦，于是同一单位采用毫秒

```
创建实例
let date = new Date()

创建指定时间
为Date传递一个表示时间的字符串 字符串格式 ：月/日/年 时/分/秒 ; 年-月-日T时：分：秒 
直接传递时间，使用逗号隔开  格式 ： 年，月（索引），日，时，分，秒
传递一个时间戳

静态方法 ：
now() : 返回当前时间的时间戳

实例方法
getFullYear() : 获取一个实例的完整的年份
getMonth() : 获取一个实例的月的索引 完整索引范围 ： 0~11
getDate() : 获取一个实例的日
getDay() : 返回一个实例的星期 范围 0~6 0 是周日
getTime() : 返回当前时间的时间戳
```

```
日期格式化

toLocaleDateString() : 将实例中时间的日期转换为本地日期（当地习惯的时间格式）字符串
toLocaleTimeString() : 将实例中时间的时间转换为本地时间字符串
toLocaleString() : 将实例中时间全部转换为本地时间字符串（上面的结合）
	参数 ： 
    1.描述语言和国家信息的字符串
        zh-CN ： 中国(简体繁体都可以)
        zh-HK ： 香港 zh-PW ： 台湾
        en-US : 美国
    2.需要一个对象，通过在对象中设置属性来对日期格式进行配置 （按照这个来优先配置）
        dateStyle : 日期格式
        timeStyle ： 时间格式
            full : 完整显示
            long
            medium
            short
        hour12 : 是否使用12小时制
        weekday : 星期显示方式
            long、short、narrow、
```

### 包装类 

​	对一些原始值调用方法时，JS解释器会默认将原始值转换为相对应的包装类对象，从而调用相应的方法

​	JS目前的包装类 ： String Number Boolean BigInt Symbol

​	对于没有包装类的原始值调用方法时，会抛出错误

### String方法

​	字符串本质就是一个字符，里面存放着字符，但是这个数组一旦被创建就无法修改

​	可以通过索引的形式来访问字符串中的字符，可以通过访问属性 ：length 来计算字符串长度

```
字符串方法（不会破坏原有字符串）

返回指定索引上的字符
at() ：可正可负，正前负后
chatAt() ：只能正

includes() : 检查一个字符串从指定位置开始是否含有指定字符串内容,并返回true和false
	两个参数 ： 指定字符内容   开始位置索引（可省略）

返回一个字符串中，指定字符内容在该字符串中的索引，没有返回-1
indexOf() ：从前开始找第一次出现的索引
indexLastOf() ： 从后开始找最后一次出现的索引
search() :
	查找符合正则表达式的内容或指定内容第一次出现的索引 

检查一个字符串的开头和结束是否符合某个内容
startWith() ： 检查开头
endWith() : 检查结尾

将一段字符串使用指定字符扩展到指定位数，如果指定位数 < 原有长度不进行扩展。两个参数 ： 位数 填充内容
padStart() ： 从前开始
padEnd() ： 从后开始

repeat() : 将字符串重复n次

replace() : 将字符串中的指定部分（最前面的指定部分,可以通过正则来查找）替换成指定内容。 两个参数 ： 想替换的部分  指定内容
replaceAll() ： 将字符串中的全部指定部分替换成指定内容


slice() 
substring() 
    都是截取字符串的部分，两个参数 ：起始位置和结束位置(不包括结束位置)
    substring会自动调整两个参数位置（当结束位置小于起始位置）

split() : 根据你提供的内容（可以是正则表达式）来分割原字符串并存放到新数组

toLoerCase() : 大写字母转小写 
toUpperCase() ：小写字母转大写

消除字符串前后空格 ：
trim()
trimStart()
trimEnd()

match() :
	匹配符合正则表达式要求的内容，并将所有符合要求的内容以数组形式输出 （跟exec差不多，但是并不会对分组部分进行多次取出，是整体取出）

matchAll() ：
	匹配符合正则表达式要求的内容，必须要求加g。返回一个迭代器(通过遍历来查询存放内容)
```

## 正则表达式

​	定义一个字符串的规则，是一个对象，必须先创建		

​	计算机可以通过正则表达式来检查或提取某一字符串中是否符合这个规则

```
定义
new RegExp(正则表达式，匹配规则)
/正则表达式/匹配规则

匹配规则 ：
i : 是否区分大小写
g : 是否全局匹配

实例方法
test() : 验证某个字符串是否符合该正则表达式
exec() : 提取某个字符串中符合正则表达式的内容
	返回一个数组，第一个存放符合最先匹配正则表达式的内容，第二个存放分组的内容（如果有的话）,第三个部分存放所在索引
	连续调用会不断往后进行匹配，知道返回null

1.在正则表达式中，大部分字符可以直接写
2. | ：或者
3. [] : 或，里面填写字符集,只要包含了里面的字符就行
    [a-z] : 小写字母
    [A-Z] : 小写字母
    [a-zA-Z] : 任意的字母
4.[^] : 表示匹配除了...外的所有字符
5. . : 表示匹配除了换行符以外的所有字符('\n','\r')
6.在正则表达式中，会使用\作为转义字符
7.其他字符集
    \w : 任意单词字符 匹配[a-zA-Z0-9_]
    \W : 非单词字符 匹配[^a-zA-Z0-9_]
    \d ： 匹配一个数字
    \D ： 匹配一个非数字
    \s : 匹配一个空白符
    \S : 匹配一个非空白符
    \b : 单词边界
    \B ：非单词边界
8.开头结尾
    ^ : 开头
    $ ： 结尾
 
量词 ：
    只会对前面的字符起作用
    {m} : 正好有m个连续的a
    {m,} :至少m个
    {m,n} : 至少m个，最多n个
    m+ : 至少一个m
    m* : 有没有都可以 0~n；
    m? : 0-1个m
```



## DOM

​	是Web API 的一部分，DOM(Document Object Model) (网页，对象，模型)

​	将网页中所有的内容都转换为对象，模型来表示对象之间的关系

​	每个对象都被成为节点，一个网页由多个节点构成，主要分文档节点、元素节点（标签）、文本节点（文字、空白符...）、属性节点(标签属性)

​	

​	使用DOM来操作网页，需要先拿到一个对象,才能完成各种操作

​	浏览器为我们提供了一个doucment对象，表示整个网页，可以通过document来获取网页中的所有对象

​	document是一个全局变量（在window中），可以直接使用

​	

```
doucment对象
	代表着整个网页
	原型链
	document ——> HTMLDocument ——> Document ——> Node ——> EventTarget ——> Object ——> null
凡是在原型链上出现的对象中的属性和方法，都可以通过Document来进行调用

document.documentElement : 获取html根元素 
document.head  ： 获取头部元素
document.title  ： 获取标题 
document.body  ： 获取body元素 
document.links  ： 获取所以超链接标签 
```



```
元素节点

获取 ：
document.getElementById() : 通过id获取一个元素节点
document.getElementsByClassName() ： 通过class获取一组元素节点，返回一个类数组对象，会实时更新这个类数组对象
document.getElementsByTagName() ： 通过标签名获取一组元素节点，类数组对象，实时更新
dicument.getElementsByName() ： 通过属性的name来获取一组元素节点，类数组对象，实时更新，主要用于表单，即使只有一个也返回类数组对象

querySelector() ： 获取符合选择器的第一个元素节点
querSelectorAll() ：根据选择器获取一组符合选择器的元素节点，类数组对象，不实时更新

创建 ：
document.createElement('标签名') :创建一个指定的标签元素节点,需要注意的是，并不会插入到页面中
```

```
标签
某个标签的原型链 ：
    某个标签 ——>HTML标签名Element——>HTMLElement——>Element——>Node——>EvenTarget——>Object——>null

通过标签获取元素节点 
element.childNodes : 获取当前元素的子节点 （会包含空白的子节点）
element.children : 获取当前元素的子元素
element.firstChild : 获取当前元素的第一个子节点
element.firsrElementChild : 获取当前元素的第一个子元素
element.lastElementChild : 获取当前元素的最后一个子元素
element.nextSibling : 获取当前元素的下一个兄弟节点
element.nextElementSibling : 获取当前元素下一个兄弟元素的节点
element.previousElementSibling : 获取当前元素上一个兄弟元素的节点
element.parentNode : 获取当前元素的父节点
element.parentElement : 获取当前元素的父元素
element.tagName : 获取当前元素的标签名
```

```
文本节点
获取和修改一个节点的文本内容
element.innerText() ： 读取或修改指定元素节点的文本内容，考虑css，因为要读取css样式，会引起重排（通过css样式去调整页面），效率上比textContent低，但是可以忽略不记 。
element.textContent() : 读取或修改指定元素节点的文本内容，不考虑css
上面两个属性在为元素节点文本内容添加标签时，会自动转换为转义字符 ： &lt;li&gt;

element.innerHTML() ： 可以直接添加标签 在使用innerHTML进行插入内容时，如果是用户输入，将会有被xss注入的风险
```

函数、方法：

​	isNaN（） ：判断一个数据是否为NaN，是返回true，否则false

​	console.time() ：一个计时器，括号内容为计时器名字，计时器名称要求唯一

​	console.timeEnd() ： 结束一个最近的计时器

​	输入：

​	prompt （）：接受用户键盘输入的数据，其返回类型为String，可以增加提示信息

​	输出：

​	alert ：通过弹出提示框来输出信息（无，Undefined）

​	confirm ：通过弹出提示框来输出信息，点击确定返回true，点击取消返回false

​	document.write ：直接在页面中显示输出信息（无，Undefined）

​	console.log ：控制台显示输出信息（String）

​	Object.create(a) :以现有对象a为原型，创建一个对象，也就是说：通过这个方式创建的对象的__ proto__指向a对象

技巧：

判断浮点数：将数模1，有余数则为浮点数，没有为整数

数组字符串索引：一个字符串可以通过类似C语言数组的形式快速访问字符串某个字符。（i[0]、i[1]...分别表示字符串i的第一个、二个...字符）

开平方 ：**.5；
